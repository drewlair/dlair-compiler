/*
Declare %token TOKEN types at the Top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%token TOKEN_EOF
%token TOKEN_IDENT
%token TOKEN_INTEGER
%token TOKEN_FLOAT
%token TOKEN_CHAR_LITERAL
%token TOKEN_STRING
%token TOKEN_BOOLEAN
%token TOKEN_EE
%token TOKEN_GE
%token TOKEN_LE
%token TOKEN_AND
%token TOKEN_OR
%token TOKEN_STRING_LITERAL

%token TOKEN_BOOLEAN_LITERAL
%token TOKEN_ARR
%token TOKEN_SEMICOLON
%token TOKEN_FLOAT_LITERAL
%token TOKEN_INCREMENT
%token TOKEN_DECREMENT
%token TOKEN_NOT
%token TOKEN_MULT
%token TOKEN_ADD
%token TOKEN_SUB
%token TOKEN_DIV
%token TOKEN_ASSIGN
%token TOKEN_MOD
%token TOKEN_EXP
%token TOKEN_GROUPING
%token TOKEN_ARR_SUBSCRIPT
%token TOKEN_FUNC_CALL
%token TOKEN_LT
%token TOKEN_GT
%token TOKEN_INTEGER_LITERAL
%token TOKEN_AUTO
%token TOKEN_VOID
%token TOKEN_FUNCTION
%token TOKEN_RETURN
%token TOKEN_COLON
%token TOKEN_COMMA
%token TOKEN_PRINT
%token TOKEN_NEGATE
%token TOKEN_IF
%token TOKEN_WHILE
%token TOKEN_FOR
%token TOKEN_ELIF
%token TOKEN_FSLASH
%token TOKEN_OPEN_BRACK
%token TOKEN_CLOSED_BRACK
%token TOKEN_OPEN_BRACE
%token TOKEN_CLOSED_BRACE
%token TOKEN_OPEN_PAR
%token TOKEN_CLOSED_PAR
%token TOKEN_CHAR
%token TOKEN_ELSE
%token TOKEN_NE
%token TOKEN_LPAREN
%token TOKEN_RPAREN


%token TOKEN_ERROR

%union {
    struct decl* decl;
    struct stmt* stmt;
    struct expr* expr;
    struct type* type;
    struct param_list* param_list;
    const char* str_val;
    int int_val;
    float float_val;

};

%type <expr> expression expr value unary incr n1 e1 expr_init expr_list func_expr end_declaration func_call arr_call index;
%type <stmt> o_statement_list statement_list statement end_func_decl open_stmt closed_stmt non_if return_expr print_expr non_return non_stmt_list;
%type <decl> f_decl_list f_declaration;
%type <param_list> decl_list decl_list_init;
%type <type> types param_types real_types TOKEN_INTEGER TOKEN_FLOAT TOKEN_BOOLEAN TOKEN_CHAR TOKEN_STRING TOKEN_AUTO TOKEN_VOID TOKEN_FUNCTION TOKEN_ARR;
%type <int_val> int_val;
%type <float_val> float_val;
%type <str_val> str_val bool_val ident_val char_val;


%{

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "include/expr.h"
#include "include/type.h"
#include "include/decl.h"
#include "include/stmt.h"
#include "include/param_list.h"







/*
Clunky: Manually declare the interface to the scanner generated by flex.
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );
extern int intval;

struct decl* parser_result;

%}

%%

/* Here is the grammar: program is the start symbol. */

program             : f_decl_list TOKEN_EOF { parser_result = $1; return 0; }
                    ;



f_decl_list         : f_declaration f_decl_list { $1->next = $2; $$ = $1; }
                    | { $$ = NULL; }
                    ;

decl_list_init      : decl_list { $$ = $1; } // normally list_decl decl_list
                    | { $$ = NULL; }
                    ;

decl_list           : ident_val TOKEN_COLON param_types TOKEN_COMMA decl_list { $$ = param_list_create($1, $3, $5); }
                    | ident_val TOKEN_COLON param_types { $$ = param_list_create( $1, $3, NULL); }
                    ;

f_declaration       : ident_val TOKEN_COLON TOKEN_FUNCTION types TOKEN_OPEN_PAR decl_list_init TOKEN_CLOSED_PAR end_func_decl { $$ = decl_create( $1, type_create(TYPE_FUNCTION, $4, $6, NULL), NULL, $8, NULL);}
                    | ident_val TOKEN_COLON types end_declaration { $$ = decl_create( $1, $3, $4, NULL, NULL );}
                    ;

end_func_decl       : TOKEN_ASSIGN TOKEN_OPEN_BRACK statement_list TOKEN_CLOSED_BRACK { $3->is_braced = true; $$ = $3;}
                    | TOKEN_SEMICOLON { $$ = NULL; }
                    ;

end_declaration     : TOKEN_ASSIGN expression TOKEN_SEMICOLON { $$ = $2;  }
                    | TOKEN_SEMICOLON { $$ = NULL; }
                    ;

param_types         : TOKEN_ARR TOKEN_OPEN_BRACE expr TOKEN_CLOSED_BRACE param_types { $$ = type_create(TYPE_ARRAY, $5, NULL, $3); }
                    | real_types { $$ = $1; }
                    ;

types               : TOKEN_ARR TOKEN_OPEN_BRACE expression TOKEN_CLOSED_BRACE types { $$ = type_create(TYPE_ARRAY, $5, NULL, $3); }
                    | real_types { $$ = $1;  }
                    ;

real_types          : TOKEN_INTEGER { $$ = type_create( TYPE_INTEGER, NULL, NULL, NULL );  }
                    | TOKEN_FLOAT { $$ = type_create( TYPE_FLOAT, NULL, NULL, NULL ); }
                    | TOKEN_BOOLEAN { $$ = type_create( TYPE_BOOLEAN, NULL, NULL, NULL ); }
                    | TOKEN_AUTO { $$ = type_create( TYPE_AUTO, NULL, NULL, NULL ); }
                    | TOKEN_STRING { $$ = type_create( TYPE_STRING, NULL, NULL, NULL ); }
                    | TOKEN_CHAR { $$ = type_create( TYPE_CHARACTER, NULL, NULL, NULL ); }
                    | TOKEN_VOID { $$ = type_create( TYPE_VOID, NULL, NULL, NULL ); }
                    ;

o_statement_list    : statement_list { $$ = $1; }
                    | { $$ = NULL; }
                    ;

statement_list      : statement o_statement_list { $1->next = $2; $$ = $1; }
                    ;

statement           : open_stmt { $$ = $1; }
                    | closed_stmt { $$ = $1; }
                    ;



non_if              : TOKEN_OPEN_BRACK statement_list TOKEN_CLOSED_BRACK { $2->is_braced = true; $$ = $2; }
                    | non_stmt_list { $$ = $1; }
                    ;

non_stmt_list       : return_expr { $$ = $1; }
                    | non_return { $$ = $1; }
                    ;

non_return          : print_expr TOKEN_SEMICOLON { $$ = $1; }
                    | ident_val TOKEN_COLON types end_declaration { $$ = stmt_create( STMT_DECL, decl_create( $1, $3, $4, NULL, NULL ), NULL, NULL, NULL, NULL, NULL, NULL ); }
                    | expression TOKEN_SEMICOLON { $$ = stmt_create( STMT_EXPR, NULL, $1, NULL, NULL, NULL, NULL, NULL);} // changed line
                    ;

print_expr          : TOKEN_PRINT expr_init { $$ = stmt_create( STMT_PRINT, NULL, $2, NULL, NULL, NULL, NULL, NULL ); }
                    ;

return_expr         : TOKEN_RETURN expr TOKEN_SEMICOLON { $$ = stmt_create( STMT_RETURN, NULL, $2, NULL, NULL, NULL, NULL, NULL ); }
                    ;






open_stmt           : TOKEN_IF TOKEN_OPEN_PAR expression TOKEN_CLOSED_PAR closed_stmt { $$ = stmt_create( STMT_IF_ELSE, NULL, $3, NULL, NULL, $5, NULL, NULL ); }
                    | TOKEN_IF TOKEN_OPEN_PAR expression TOKEN_CLOSED_PAR open_stmt { $$ = stmt_create( STMT_IF_ELSE, NULL, $3, NULL, NULL, $5, NULL, NULL ); }
                    | TOKEN_IF TOKEN_OPEN_PAR expression TOKEN_CLOSED_PAR closed_stmt TOKEN_ELSE open_stmt { $$ = stmt_create( STMT_IF_ELSE, NULL, $3, NULL, NULL, $5, $7, NULL ); }
                    | TOKEN_FOR TOKEN_OPEN_PAR expr TOKEN_SEMICOLON expr TOKEN_SEMICOLON expr TOKEN_CLOSED_PAR open_stmt { $$ = stmt_create( STMT_FOR, NULL, $3, $5, $7, $9, NULL, NULL ); }
                    ;

closed_stmt         : non_if { $$ = $1; }
                    | TOKEN_IF TOKEN_OPEN_PAR expression TOKEN_CLOSED_PAR closed_stmt TOKEN_ELSE closed_stmt { $$ = stmt_create( STMT_IF_ELSE, NULL, $3, NULL, NULL, $5, $7, NULL ); }
                    | TOKEN_FOR TOKEN_OPEN_PAR expr TOKEN_SEMICOLON expr TOKEN_SEMICOLON expr TOKEN_CLOSED_PAR closed_stmt { $$ = stmt_create( STMT_FOR, NULL, $3, $5, $7, $9, NULL, NULL ); }
                    ;

expr_init           : expr_list { $$ = $1; }
                    | { $$ = NULL; }
                    ;

expr_list           : expression TOKEN_COMMA expr_list { $$ = expr_create(EXPR_LIST, $1, $3); }
                    | expression { $$ = expr_create( EXPR_LIST, $1, NULL); }
                    ;


expr                : expression { $$ = $1; }
                    | { $$ = NULL; }
                    ;


expression          : expression TOKEN_ASSIGN e1 { $$ = expr_create( EXPR_ASSIGN, $1, $3 ); }
                    | e1 { $$ = $1; }
                    ;


e1                  : e1 TOKEN_ADD n1 { $$ = expr_create( EXPR_ADD, $1, $3 ); }
                    | e1 TOKEN_SUB n1 { $$ = expr_create( EXPR_SUB, $1, $3 ); }
                    | e1 TOKEN_EE n1 { $$ = expr_create( EXPR_EE, $1, $3 ); }
                    | e1 TOKEN_NE n1 { $$ = expr_create( EXPR_NE, $1, $3 ); }
                    | e1 TOKEN_GE n1 { $$ = expr_create( EXPR_GE, $1, $3 ); }
                    | e1 TOKEN_LE n1 { $$ = expr_create( EXPR_LE, $1, $3 ); }
                    | e1 TOKEN_GT n1 { $$ = expr_create( EXPR_GT, $1, $3 ); }
                    | e1 TOKEN_LT n1 { $$ = expr_create( EXPR_LT, $1, $3 ); }
                    | e1 TOKEN_OR n1 { $$ = expr_create( EXPR_OR, $1, $3 ); }
                    | n1             { $$ = $1; }
                    ;

n1                  : n1 TOKEN_MULT unary {  $$ = expr_create( EXPR_MUL, $1, $3 ); }
                    | n1 TOKEN_DIV  unary {  $$ = expr_create( EXPR_DIV, $1, $3 ); }
                    | n1 TOKEN_AND  unary {  $$ = expr_create( EXPR_AND, $1, $3 ); }
                    | n1 TOKEN_EXP  unary {  $$ = expr_create( EXPR_EXP, $1, $3 ); }
                    | n1 TOKEN_MOD  unary {  $$ = expr_create( EXPR_MOD, $1, $3 ); }
                    | unary               {  $$ = $1; }
                    ;

unary               : TOKEN_ADD unary { $$ = expr_create( EXPR_POS, $2, NULL );  }
                    | TOKEN_SUB unary { $$ = expr_create( EXPR_NEGATE, $2, NULL ); }
                    | TOKEN_NOT unary { $$ = expr_create( EXPR_NOT, $2, NULL ); }
                    | incr { $$ = $1; }
                    ;

incr                : value TOKEN_INCREMENT { $$ = expr_create( EXPR_INCR, $1, NULL); }
                    | value TOKEN_DECREMENT { $$ = expr_create( EXPR_DECR, $1, NULL); }
                    | value { $$ = $1;  }
                    ;

value               : int_val {  $$ = expr_create_integer_literal($1); }
                    | float_val { $$ = expr_create_float_literal($1); }
                    | func_expr { $$ = $1; }
                    | char_val { $$ = expr_create_char_literal($1[1]); }
                    | str_val { $$ = expr_create_string_literal($1); }
                    | bool_val { $$ = expr_create_boolean_literal($1);}
                    | TOKEN_OPEN_PAR expr_init TOKEN_CLOSED_PAR { $$ = expr_create( EXPR_PAREN, $2, NULL); }
                    | TOKEN_OPEN_BRACK expr_list TOKEN_CLOSED_BRACK { $$ = expr_create( EXPR_LIST_ARRAY, $2, NULL ); }
                    ;

int_val             : TOKEN_INTEGER_LITERAL { $$ = atoi(yytext); }
                    ;

float_val           : TOKEN_FLOAT_LITERAL   { $$ = atof(yytext); }
                    ;

bool_val            : TOKEN_BOOLEAN_LITERAL { $$ = yytext; }
                    ;

char_val            : TOKEN_CHAR_LITERAL    { $$ = yytext; }
                    ;

str_val             : TOKEN_STRING_LITERAL  { $$ = strdup(yytext); }
                    ;

func_expr           : ident_val { $$ = expr_create_name( $1, EXPR_IDENT_LITERAL ); }
                    | func_call { $$ = $1; }
                    | arr_call  { $$ = $1; }
                    ;

func_call           : ident_val TOKEN_OPEN_PAR expr_init TOKEN_CLOSED_PAR { $$ = expr_create( EXPR_CALL, expr_create_name( $1, EXPR_IDENT_LITERAL ), $3); }
                    ;

arr_call            : ident_val index { $$ = expr_create( EXPR_INDEX, expr_create_name( $1, EXPR_IDENT_LITERAL ), $2 ); }
                    ;

index               : TOKEN_OPEN_BRACE expression TOKEN_CLOSED_BRACE index { $$ = expr_create( EXPR_INDEX_LIST, $2, $4); }
                    | TOKEN_OPEN_BRACE expression TOKEN_CLOSED_BRACE { $$ = expr_create( EXPR_INDEX_LIST, $2, NULL); }
                    ;

ident_val           : TOKEN_IDENT   { $$ = strdup(yytext); }
                    ;


%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	return 0;
}
